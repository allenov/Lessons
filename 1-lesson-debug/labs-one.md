#### Задание 1: Просмотр и поиск в файлах
1. Создайте текстовый файл и заполните его произвольным содержимым с помощью nano/vi и тд. Например:
```
CI/CD — это одна из DevOps-практик. Она также относится и к agile-практикам: автоматизация развертывания позволяет разработчикам сосредоточиться на реализации бизнес-требований, на качестве кода и безопасности.

Определение CI/CD

Непрерывная интеграция — это методология разработки и набор практик, при которых в код вносятся небольшие изменения с частыми коммитами. И поскольку большинство современных приложений разрабатываются с использованием различных платформ и инструментов, то появляется необходимость в механизме интеграции и тестировании вносимых изменений.

С технической точки зрения, цель CI — обеспечить последовательный и автоматизированный способ сборки, упаковки и тестирования приложений. При налаженном процессе непрерывной интеграции разработчики с большей вероятностью будут делать частые коммиты, что, в свою очередь, будет способствовать улучшению коммуникации и повышению качества программного обеспечения.

Непрерывная поставка начинается там, где заканчивается непрерывная интеграция. Она автоматизирует развертывание приложений в различные окружения: большинство разработчиков работают как с продакшн-окружением, так и со средами разработки и тестирования.

Инструменты CI/CD помогают настраивать специфические параметры окружения, которые конфигурируются при развертывании. А также CI/CD-автоматизация выполняет необходимые запросы к веб-серверам, базам данных и другим сервисам, которые могут нуждаться в перезапуске или выполнении каких-то дополнительных действий при развертывании приложения.

Непрерывная интеграция и непрерывная поставка нуждаются в непрерывном тестировании, поскольку конечная цель — разработка качественных приложений. Непрерывное тестирование часто реализуется в виде набора различных автоматизированных тестов (регрессионных, производительности и других), которые выполняются в CI/CD-конвейере.

Зрелая практика CI/CD позволяет реализовать непрерывное развертывание: при успешном прохождении кода через CI/CD-конвейер, сборки автоматически развертываются в продакшн-окружении. Команды, практикующие непрерывную поставку, могут позволить себе ежедневное или даже ежечасное развертывание. Хотя здесь стоит отметить, что непрерывная поставка подходит не для всех бизнес-приложений.

P.S Текст, кстати, тоже можно прочитать полезно.
```

2. Используйте `cat` для просмотра содержимого файла.
3. Найдите строки, содержащие определённое слово с помощью `grep`. Например все вхождения 'CI/CD'.

#### Задание 2: Использование пайпов (конвеера)
1. Используйте `ls -la` и передайте вывод в `grep`, чтобы найти файлы с определённым расширением.

#### Задание 3: Анализ использования дискового пространства
1. Используйте `df -ht`, чтобы определить, сколько свободного места на дисках.
2. Используйте `du -h` для анализа размера каталогов.
3. Запустите `ncdu` и исследуйте, какие файлы занимают больше всего места.

### Дополнительные полезные команды

- **`head`**: Показывает первые несколько строк файла.
  ```bash
  head filename.txt
  ```

- **`find`**: Ищет файлы в директориях по заданному критерию.
  ```bash
  find /path -name '*.txt'
  ```

- **`awk`**: Мощный инструмент для обработки текстовых данных.
  ```bash
  awk '{ print $1 }' filename.txt
  ```

- **`tail`**: Показывает последние несколько строк файла.
  ```bash
  tail -n 2 filename.txt
  ```
#### Задание 5: Дисковая нагрузка и LA.
Запускаем два ssh соединения.\
В первом делаем:

``` bash
sudo apt-get install iotop htop
apt install git
git clone https://github.com/allenov/Lessons.git
cd Lessons/1-lesson-debug/
chmod +x la-tresh.sh
./la-tresh.sh
```

Во втором htop. Смотрим минутку. Далее запускаем iotop. Смотрим минутку. Опять htop. Смотрим. \
Закрываем в первом окне с помощью ctrl + c. \
Пишем свои выводы:

#### Задание 6: Большая загрузка памяти.

В первом делаем:
``` bash
swapoff -a
```
Проверяем что swap выключен в htop.

``` bash
chmod +x leak-mem.sh
./leak-mem.sh
```

Во втором htop. Смотрим. Ростет память и ожидаем как она резко освободится. \
Переходим в первое окно. \
Killed \
Вот мы и познакомились с oom-killer. \
Смотрим dmesg. Можно добавить tail или grep. Смотрим journalctl.

``` bash
dmesg
[ 1191.515017] oom-kill:constraint=CONSTRAINT_NONE,nodemask=(null),cpuset=/,mems_allowed=0,global_oom,task_memcg=/user.slice/user-0.slice/session-1.scope,task=leak-mem.sh,pid=1852,uid=0
[ 1191.515038] Out of memory: Killed process 1852 (leak-mem.sh) total-vm:7690560kB, anon-rss:7608976kB, file-rss:1888kB, shmem-rss:0kB, UID:0 pgtables:14956kB oom_score_adj:0

journalctl -k

oom-kill:constraint=CONSTRAINT_NONE,nodemask=(null),cpuset=/,mems_allowed=0,global_oom,task_memcg=/user.slice/user-0.slice/session-1.scope,task=leak-mem.sh,pid=1334,uid=0
Out of memory: Killed process 1334 (leak-mem.sh) total-vm:7690560kB, anon-rss:7609748kB, file-rss:1992kB, shmem-rss:0kB, UID:0 pgtables:14972kB oom_score_adj:0
leak-mem.sh invoked oom-killer: gfp_mask=0x1100dca(GFP_HIGHUSER_MOVABLE|__GFP_ZERO), order=0, oom_score_adj=0
```


```
OOM Killer — механизм ядра Linux, который при исчерпании доступной памяти принудительно завершает отдельные процессы на сервере для освобождения RAM. Освободившаяся память передается ядру ОС, а после перенаправляется тому процессу, которому ее было недостаточно.

OOM Killer использует определенный набор правил для выбора процесса, который нужно «убить». В целом, в первую очередь будут завершены недавно запущенные пользовательские процессы, которые требуют большого объема памяти и/или имеют множество дочерних процессов; в последнюю очередь будут завершаться системные процессы пользователя root, запущенные значительное время назад.

В связи с тем, что OOM killer «убивает» процессы с помощью SIGKILL, что не дает возможности корректного завершения процессов, сохранения данных и пр., частое срабатывание этого механизма может приводить к серьезным последствиям в работе системе.
```

#### Задание 7: Большая загрузка цпу и рост LA.

В первом делаем:

``` bash
chmod +x tresh.sh
./tresh.sh
```

Во втором htop. Смотрим минутку.

Переходим в первое окно.
Жмем ctrl + c.

Во втором опять htop смотрим.

Задание со звездочкой найти и как-то убить процессы которые вызывают нагрузку на CPU.

Перезагружаем vm.

