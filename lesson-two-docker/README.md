# Введение в Docker и контейнеризацию

## Цели лекции:
- Познакомиться с основными концепциями Docker и контейнеризации.
- Научиться использовать Docker для создания, управления и развертывания контейнеров.
- Понять, как Docker использует cgroups и namespaces для изоляции контейнеров.


### Теоретическая часть

#### 1. Введение в контейнеризацию
- **Контейнеризация** — это метод виртуализации на уровне операционной системы, который позволяет запускать и управлять приложениями в изолированных средах, называемых контейнерами.
- Контейнеры позволяют разработчикам упаковывать приложения с их зависимостями в единый артефакт, который можно запускать в любой среде.

#### 2. Различия между виртуализацией и контейнеризацией
- **Виртуализация** использует гипервизор для запуска нескольких виртуальных машин (VM), каждая из которых имеет собственную ОС и ресурсы. Это создает изоляцию на уровне оборудования.
  - Преимущества: высокая изоляция, возможность запускать разные ОС.
  - Недостатки: большие накладные расходы на ресурсы.

- **Контейнеризация** работает на уровне операционной системы, изолируя процессы с помощью cgroups и namespaces, но без эмуляции аппаратного обеспечения.
  - Преимущества: более высокая производительность, меньший объем занимаемой памяти, быстрое развертывание.
  - Недостатки: все контейнеры используют одну и ту же ОС, что может ограничивать вариативность.

#### 3. Бизнес-фича: сокращение Time-to-Market
- Использование Docker позволяет значительно ускорить процесс разработки, тестирования и развертывания приложений. Это достигается благодаря:
  - Единообразным средам: образы Docker гарантируют, что приложение будет работать одинаково в любой среде.
  - Упрощенному CI/CD: интеграция Docker с инструментами CI/CD автоматизирует развертывание.
  - Повышенной мобильности: контейнеры легко перемещать между серверами и облаками.

#### 4. Технологии изоляции в Docker
- **cgroups (control groups)**: Технология, используемая для ограничения и мониторинга использования ресурсов (ЦП, память, дисковый ввод/вывод) контейнерами.
- **namespaces**: Обеспечивают изоляцию контейнеров, позволяя им работать как отдельные экземпляры в рамках одной системы (изолируют процессы, сеть, точки монтирования и т. д.).

#### 5. Основные команды Docker
- `docker build`: Собирает образ.
- `docker run`: Запускает новый контейнер.
- `docker ps`: Показывает запущенные контейнеры.
- `docker stop`: Останавливает контейнер.
- `docker rm`: Удаляет контейнер.
- `docker images`: Показывает локально сохранённые образы.
- `docker rmi`: Удаляет образ.

---

### Почему важно знать Docker

#### Системные администраторы
- Управление ресурсами, настройка сетей и обеспечение безопасности контейнеров.

#### Разработчики
- Возможность разрабатывать и тестировать приложения в идентичных средах, минимизируя проблемы с окружением.

#### DevOps-инженеры
- Автоматизация процессов развертывания и обеспечение надежности CI/CD пайплайнов.


### Практическая часть

#### Задание 1: Установка Docker
1. Установите Docker на вашу систему, следуя официальной документации для вашей операционной системы.


   [Docker install](https://docs.docker.com/engine/install/)

---

   ![Выбираем os](/lesson-two-docker/images/image1.png)


   ![Выбираем os](/lesson-two-docker/images/image2.png)

---

2. Проверьте установку, запустив команду:
   ```bash
   docker --version
   ```

#### Задание 2: Первый контейнер
1. Запустите контейнер с Ubuntu:
   ```bash
   docker run -it ubuntu bash
   ```
2. Внутри контейнера выполните несколько команд для проверки:
   ```bash
   ls
   pwd
   exit
   ```

#### Задание 3: Работа с образами
1. Загрузите образ nginx:
   ```bash
   docker pull nginx
   ```
2. Посмотрите список локальных образов:
   ```bash
   docker images
   ```

#### Задание 4: Создание и управление контейнерами
1. Запустите контейнер с nginx:
   ```bash
   docker run -d -p 8080:80 nginx
   ```
2. Проверьте работу nginx, открыв в браузере `http://localhost:8080`.
3. Остановите контейнер:
   ```bash
   docker stop <container_id>
   ```
4. Удалите контейнер:
   ```bash
   docker rm <container_id>
   ```


### Dockerfile: Основные понятия

**Dockerfile** — это текстовый файл, содержащий инструкции для автоматизации сборки Docker-образа. Это своего рода "рецепт", который определяет, как создать окружение, необходимое для работы вашего приложения.

#### Основные инструкции Dockerfile

1. **FROM**: Указывает базовый образ, от которого будет происходить сборка. Это первая строка в Dockerfile.
   ```dockerfile
   FROM ubuntu:latest
   ```
2. **RUN**: Выполняет команды в контейнере во время сборки образа. Часто используется для установки пакетов.
   ```dockerfile
   RUN apt-get update && apt-get install -y nginx
   ```

3. **COPY** или **ADD**: Копирует файлы/директории с локальной машины в образ.
   ```dockerfile
   COPY . /app
   ```

4. **CMD**: Задает команду, которая будет выполнена при запуске контейнера. В отличие от RUN, CMD используется для выполнения команд в запущенном контейнере.
   ```dockerfile
   CMD ["nginx", "-g", "daemon off;"]
   ```

5. **EXPOSE**: Указывает, какой порт будет доступен для взаимодействия с контейнером.
   ```dockerfile
   EXPOSE 80
   ```

6. **ENV**: Устанавливает переменные окружения.
   ```dockerfile
   ENV APP_ENV production
   ```

7. **WORKDIR**: Устанавливает рабочую директорию для последующих инструкций.
   ```dockerfile
   WORKDIR /app
   ```

8. **ENTRYPOINT**: Позволяет задать команду, которая будет выполняться как основная в контейнере.
   ```dockerfile
   ENTRYPOINT ["nginx"]
   ```

#### Dockerfile: дополнительные аспекты

#### Разница между ARG и ENV
- **ARG**:
  - Используется для передачи переменных на этапе сборки образа.
  - Эти переменные недоступны в запущенном контейнере.
  ```dockerfile
  ARG BUILD_VERSION
  RUN echo "Build version is $BUILD_VERSION"
  ```

- **ENV**:
  - Устанавливает переменные окружения для контейнера во время его выполнения.
  - Эти переменные доступны внутри контейнера.
  ```dockerfile
  ENV APP_ENV=production
  CMD echo "Environment is $APP_ENV"
  ```

#### Разница между CMD и ENTRYPOINT
- **CMD**:
  - Устанавливает команду по умолчанию, которую можно переопределить при запуске контейнера.
  - Обычно используется для задания параметров.
  ```dockerfile
  CMD ["nginx", "-g", "daemon off;"]
  ```

- **ENTRYPOINT**:
  - Устанавливает основную команду, которая всегда выполняется.
  - Аргументы можно добавлять при запуске контейнера.
  ```dockerfile
  ENTRYPOINT ["nginx"]
  ```

#### Разница между ADD и COPY
- **ADD**:
  - Может копировать файлы и архивы (с автоматической распаковкой) из локальной машины или URL.
  - Подходит для сложных сценариев, но может привести к избыточным действиям.
  ```dockerfile
  ADD file.tar.gz /app
  ```

- **COPY**:
  - Простая команда для копирования файлов и директорий из локальной файловой системы в образ Docker.
  - Рекомендуется использовать COPY для большей предсказуемости.
  ```dockerfile
  COPY . /app
  ```

---


### Слои и лучшие практики написания Dockerfile

#### Что такое слои в Docker

- Каждый образ Docker состоит из слоев. Каждый слой представляет собой результат выполнения одной инструкции Dockerfile (например, `FROM`, `RUN`, `COPY`).
- Слои кэшируются, что позволяет ускорить сборку образов, если слои не изменились.
- Изменение одного слоя приводит к пересборке всех последующих слоев.

#### Почему объединяют команды в `RUN`

- Каждая инструкция `RUN` создает новый слой, что увеличивает размер образа.
- Объединение команд позволяет сократить количество слоев, что уменьшает итоговый размер образа и ускоряет его сборку.

##### Пример хорошего подхода:

```dockerfile
RUN apt-get update && apt-get install -y \
    curl \
    vim && \
    apt-get clean && rm -rf /var/lib/apt/lists/*
```

##### Пример плохого подхода:

```dockerfile
RUN apt-get update
RUN apt-get install -y curl
RUN apt-get install -y vim
RUN apt-get clean
```

- В этом случае создается несколько лишних слоев, что увеличивает размер образа.

#### Рекомендуемая последовательность написания Dockerfile

1. **`FROM`**: Укажите базовый образ.

   ```dockerfile
   FROM ubuntu:20.04
   ```

2. **`ENV`**: Задайте переменные окружения. (не обязательно)

   ```dockerfile
   ENV APP_ENV=production
   ```

3. **`RUN`**: Установите зависимости и выполните необходимые действия.

   ```dockerfile
   RUN apt-get update && apt-get install -y \
       curl \
       vim && \
       apt-get clean && rm -rf /var/lib/apt/lists/*
   ```

4. **`COPY`**** или ****`ADD`**: Скопируйте файлы в образ.

   ```dockerfile
   COPY . /app
   ```

5. **`EXPOSE`**: Укажите порты, которые будет использовать приложение.

   ```dockerfile
   EXPOSE 8080
   ```

6. **`CMD`**** или ****`ENTRYPOINT`**: Определите команду для запуска приложения.

   ```dockerfile
   CMD ["node", "app.js"]
   ```

#### Почему это важно

- **Производительность**: Сокращение слоев уменьшает размер образа и ускоряет его загрузку и развертывание.
- **Простота поддержки**: Логичная структура Dockerfile упрощает понимание и модификацию.
- **Эффективность кэширования**: Упорядочение инструкций сохраняет больше кэша, ускоряя сборку. Например, чаще изменяемые инструкции, такие как `COPY` или `ADD`, следует располагать ближе к концу Dockerfile. Это позволяет реже пересобирать неизменные слои, такие как установка базовых зависимостей.

---

### Установка имени контейнеру

- Контейнеры по умолчанию получают случайно сгенерированные имена. Однако, вы можете задавать имена вручную для удобства.

#### Пример:
- Задание имени контейнеру при запуске:
  ```bash
  docker run --name my-container -d my-app:1.0.0
  ```
- Проверка работы:
  ```bash
  docker ps
  ```
  В выводе вы увидите контейнер с именем `my-container` вместо случайного имени.

#### Преимущества:
- Удобство работы с несколькими контейнерами.
- Легкость идентификации контейнеров в логах и командах управления.

---

### Монтирование файлов и папок в Docker

- Docker позволяет монтировать локальные файлы и директории в контейнеры для обеспечения гибкости и удобства работы.

#### Задание 5: Виды монтирования
1. **bind-mount**:
   - Прямое сопоставление файлов/папок с локальной машины в контейнере.
   ```bash
   docker run -v /local/path:/container/path my-image
   ```

2. **volume**:
   - Используется для хранения данных, которые должны сохраняться независимо от жизненного цикла контейнера.
   ```bash
   docker volume create my-volume
   docker run -v my-volume:/container/path my-image
   ```

#### Пример использования
- Запустим контейнер с монтированием локальной директории:
  ```bash
  docker run -v $(pwd)/data:/app/data my-image
  ```
  В данном примере локальная папка `data` будет доступна в контейнере по пути `/app/data`.

---

### Практическая часть

#### Задание 6: Исследование монтирования
1. Создайте локальную директорию `shared-data` и добавьте в нее файл `test.txt`.
2. Запустите контейнер с монтированием этой директории:
   ```bash
   docker run -it -v $(pwd)/shared-data:/app/data ubuntu bash
   ```
3. Внутри контейнера проверьте содержимое папки `/app/data`.
4. Измените файл `test.txt` локально и убедитесь, что изменения видны внутри контейнера.


---

### Docker: Работа с образами и registry (реестрами)

#### Команды `docker pull` и `docker push`

- **docker pull**: используется для загрузки образа из registry в локальное хранилище Docker.
  ```bash
  docker pull my-registry.com/my-app:1.0.0
  ```
- **docker push**: позволяет загрузить локально созданный образ в registry Docker.
  ```bash
  docker push my-registry.com/my-app:1.0.0
  ```

#### Локальные registry образов

- Для хранения Docker-образов можно использовать локальные registry. Наиболее популярные варианты:
  - **Nexus**: мощный инструмент для управления зависимостями, включая образы контейнеров.
  - **Harbor**: современный registry контейнеров с поддержкой управления правами доступа, сканирования безопасности и репликации образов.

#### Ограничения Docker Hub

- **Ограничения по количеству загрузок**: Для бесплатных аккаунтов на Docker Hub существуют лимиты на количество скачиваний образов за определенный период.
- **Возможные сбои и блокировки**: Бывают случаи временной недоступности Docker Hub, что может повлиять на процессы развертывания, зависящие от этого сервиса.

#### Почему локальные registry важны

- Локальные registry позволяют:
  - Хранить образы внутри организации, обеспечивая доступ даже при проблемах с внешними сервисами.
  - Избежать ограничений Docker Hub, например, на количество загрузок.
  - Управлять безопасностью и доступом к образам, используя инструменты вроде Nexus или Harbor.

Использование локальных registry упрощает управление образами внутри организации, обеспечивает безопасность и ускоряет доступ к часто используемым образам.

---

### Важность тегов на образах

- Теги позволяют различать версии одного и того же Docker-образа. Это критически важно для управления версиями приложений.

#### Основные рекомендации:
1. **Указывайте конкретные версии:**
   - Вместо использования `latest` (который может неожиданно измениться) используйте точные теги, например `1.0.0`.
   ```bash
   docker pull nginx:1.23.3
   ```
2. **Используйте семантическое версионирование:**
   - Это позволяет идентифицировать мажорные, минорные и патч-версии.
3. **Локальные теги:**
   - Для тестирования используйте понятные локальные теги, например `my-app:dev` или `my-app:test`.

#### Несколько тегов для одного образа
- Docker позволяет задавать несколько тегов для одного и того же образа. Например:
  ```bash
  docker build -t my-app:1.0.0 -t my-app:latest .
  ```
  В этом случае образ будет доступен как с тегом `1.0.0`, так и с тегом `latest`.

#### Что такое `latest`
- Тег `latest` — это просто стандартный тег по умолчанию, который назначается образу, если вы не указали другой. Он не означает "самую новую версию", поэтому его использование может быть рискованным.
  ```bash
  docker pull my-app:latest
  ```
