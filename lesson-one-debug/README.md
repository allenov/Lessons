# Основные команды Linux

## Цели лекции:
- Научиться использовать базовые команды Linux для работы с файлами и каталогами.
- Понять, как использовать пайпы(конвеер) и операторы для управления выводом команд.
- Изучить основные утилиты для анализа использования дискового пространства.

### Теоретическая часть

#### 1. Работа с файлами и выводом
- **`cat`**: Используется для вывода содержимого файлов.
  ```bash
  cat filename.txt
  ```
  - Примеры использования: объединение файлов, просмотр содержимого.

- **`grep`**: Мощный инструмент для поиска строк в текстовых файлах соответствующих заданному шаблону.
- Пример: `grep 'pattern' file`
- Полезные параметры:
  - `-i`: игнорирование регистра.
  - `-r`: рекурсивный поиск.
  - `-n`: вывод номеров строк.
  - `-v`: вывести строки, не соответствующие шаблону. Обратный поиск.
  ```bash
  grep 'pattern' filename.txt
  ```

- **`tail`**: Показывает последние несколько строк файла.
  ```bash
  tail filename.txt
  ```
  - Опции: `-f` (следить за добавлением строк), `-n` (указать количество строк).

#### 2. Управление выводом и пайпы (конвеер)
- **Пайп `|`**: Используется для передачи вывода одной команды в качестве ввода другой команды.
  ```bash
  cat filename.txt | grep 'pattern'
  ```

- **Оператор `||`**: Используется для выполнения второй команды только если первая завершилась с ошибкой.
  ```bash
  command1 || command2
  ```

#### 3. Работа с файловой системой
- **`df -ht`**: Показывает информацию о файловых системах и их использовании.
  ```bash
  df -ht
  ```

- **`ls -la`**: Показывает подробный список файлов и каталогов.
  ```bash
  ls -la
  ```
  - Опции: `-l` (подробная информация), `-a` (включая скрытые файлы).

- **`du`**: Показывает использование дискового пространства файлами и директориями.
  ```bash
  du -h
  ```
  - Опции: `-h` (человекочитаемый формат).

- **`ncdu`**: Интерактивный просмотрщик использования дискового пространства.
  - Установка:
    ```bash
    sudo apt-get install ncdu  # Для Debian/Ubuntu
    sudo yum install ncdu      # Для CentOS/RHEL
    ```
  - Использование:
    ```bash
    ncdu /
    ```

---

### Переменные окружения.

#### Что такое переменные окружения
- Переменные окружения (environment variables) — это пары ключ-значение, которые хранят данные, используемые приложениями и системными процессами.
- Они помогают задавать конфигурацию без необходимости изменять исходный код.

1. **Простой способ задания переменной в текущей сессии:**
   ```bash
   variable="keklol"
   echo $variable
   ```
   - Переменная доступна только внутри текущей сессии (или скрипта).
   - Она **не наследуется** дочерними процессами.

2. **Использование команды `export`:**
   ```bash
   export variable2="keklols"
   echo $variable2
   ```
   - Переменная становится доступной для всех дочерних процессов текущей сессии.
   - Это важно для передачи переменных в запускаемые процессы, такие как приложения или скрипты.

#### Разница между `variable` и `export variable`
| **Характеристика**         | `variable="value"`                       | `export variable="value"`                 |
|----------------------------|--------------------------------------------|--------------------------------------------|
| Область действия           | Только текущая сессия                     | Текущая сессия + дочерние процессы         |
| Доступ в дочерних процессах| Нет                                        | Да                                         |
| Типичные случаи использования| Локальные переменные для скриптов         | Переменные для конфигурации приложений     |

#### Пример:
```bash
variable="local_value"
export variable2="global_value"

bash -c 'echo $variable'   # Пустой вывод, так как переменная не экспортирована
bash -c 'echo $variable2'  # Вывод: global_value
```

#### Почему важно знать о переменных окружения
- **Гибкость:** Позволяют изменять поведение приложения без модификации кода.
- **Безопасность:** Секретные данные, такие как пароли и ключи, можно хранить в переменных, а не в коде.
- **Универсальность:** Упрощают настройку приложений в разных средах (разработка, тестирование, продакшн).


### Практическая часть


### Заключение

Эти команды и задания обеспечат хорошую основу для работы в командной строке Linux и помогут освоить эффективные методы управления файлами и ресурсами системы.


# Отладка и диагностика в Linux

## Введение
Отладка и диагностика в Linux являются важными навыками для системных администраторов, программистов и DevOps-инженеров. В этом уроке мы рассмотрим основные инструменты, которые помогут вам находить и устранять проблемы на сервере.

### Что мы изучим:
1. **Мониторинг состояния системы:** htop, iotop, lsof, free.
2. **Управление процессами:** ps, kill.
3. **Работа с сетевыми соединениями:** ss.
4. **Журналы системы:** journalctl, dmesg.
6. **Работа с HTTP-запросами:** curl.

---

## 1. Мониторинг состояния системы

### htop
`htop` — удобный инструмент для мониторинга процессов в режиме реального времени.
- Запуск: `htop`
- Важные показатели:
  - LA (Load Average): показывает среднее количество процессов, ожидающих выполнения за последние 1, 5 и 15 минут.
  - CPU, MEM, и SWAP: отображают загрузку процессора, использование оперативной памяти и подкачки.

**Практика:**
1. Установите `htop`, если он не установлен: `sudo apt install htop` (Debian/Ubuntu).
2. Запустите `htop` и найдите процесс с наибольшей нагрузкой на CPU.
3. Нажмите `F3`, чтобы найти конкретный процесс по имени.

### iotop
`iotop` позволяет отслеживать, какие процессы активно используют дисковую подсистему.
- Запуск: `sudo iotop`
- Ключевые параметры:
  - **DISK READ** и **DISK WRITE**: отображают, сколько данных читает и записывает процесс.

**Практика:**
1. Установите `iotop`: `sudo apt install iotop`.
2. Определите процесс, вызывающий высокую нагрузку на диск.

### free
`free` — команда для отображения состояния памяти.
- Запуск: `free -h`
- Показатели:
  - **total**: общий объем памяти.
  - **used**: используемая память.
  - **free**: свободная память.
  - **available**: доступная для приложений память.
  - **shared**: память, разделяемая между процессами.
  - **buff/cache**: объем памяти, используемой для буферов и кэша.

**Практика:**
1. Выполните `free -h`.
2. Найдите, сколько памяти доступно для приложений и сколько используется для буферов/кэша.

### Swap
Swap (раздел подкачки) используется, когда оперативная память заканчивается. Это область диска, выделенная для временного хранения данных, вытесненных из оперативной памяти.
- Проверить состояние swap: `free -h` или `swapon -s`.
- Отключение swap: `sudo swapoff -a`.
- Удаление swap из fstab (чтобы не активировался при загрузке):
  1. Откройте файл: `sudo nano /etc/fstab`.
  2. Найдите строку с упоминанием swap и удалите её.
  3. Перезагрузите систему.

**Практика:**
1. Отключите swap: `sudo swapoff -a`.
2. Убедитесь, что swap отключен: `free -h`.



### lsof
`lsof` показывает открытые файлы и сетевые соединения.
- Пример: `lsof -i :80`
- Полезные команды:
  - `lsof -u <пользователь>`: файлы, открытые указанным пользователем.

**Практика:**
1. Найдите процесс, использующий порт 22: `lsof -i :22`.
2. Проверьте, какие файлы открыты конкретным пользователем: `lsof -u <имя_пользователя>`.

---

## 2. Управление процессами

### ps
`ps` отображает список процессов в системе.
- Пример: `ps aux`
- Полезные параметры:
  - **USER**: пользователь, запустивший процесс.
  - **PID**: идентификатор процесса.
  - **%CPU** и **%MEM**: использование CPU и памяти процессом.

**Практика:**
1. Выполните `ps aux | grep <имя процесса>`.
2. Найдите процесс, потребляющий наибольший объем ресурсов.

### kill
`kill` используется для завершения процессов.
- Пример: `kill -9 <PID>`

**Практика:**
1. Найдите PID процесса, используя `ps` или `htop`.
2. Завершите процесс с помощью `kill`.

---

## 3. Работа с сетевыми соединениями

### ss
`ss` — утилита для анализа сетевых подключений.
- Пример: `ss -tuln`
- Ключевые параметры:
  - **-t**: отображение TCP-подключений.
  - **-u**: отображение UDP-подключений.
  - **-l**: отображение прослушиваемых портов.
  - **-n**: отображение адресов без преобразования в DNS.
  - **-p**: отображение процессов, связанных с подключениями.

**Практика:**
1. Найдите все порты, которые слушает система: `ss -l`.
2. Найдите все активные подключения на порт 80: `ss -tulpn | grep :80`.

---

## 4. Журналы системы

### journalctl
`journalctl` используется для просмотра системных логов.
- Пример: `journalctl -u <имя_сервиса>`
- Полезные опции:
  - `-b`: логи текущей загрузки.
  - `-f`: режим реального времени (следить за логами).
  - `-p <уровень>`: фильтрация по уровню приоритета (например, `-p err` для ошибок).
  - `-k`: отображение только сообщений ядра.

**Практика:**
1. Посмотрите логи службы `sshd`: `journalctl -u sshd`.
2. Найдите ошибки системы: `journalctl -p err`.
3. Отобразите только сообщения ядра: `journalctl -k`.

### dmesg
`dmesg` выводит сообщения ядра Linux.
- Полезно для диагностики оборудования и драйверов.
- Пример: `dmesg | grep error`

**Практика:**
1. Найдите ошибки, связанные с оборудованием: `dmesg | grep fail`.
2. Просмотрите последние записи: `dmesg | tail`.

---

## 5. Работа с HTTP-запросами

### curl
`curl` используется для выполнения HTTP-запросов.
- Пример: `curl -I https://example.com`
- Полезные параметры:
  - `-I`: только заголовки ответа.
  - `-L`: следовать за редиректами.

**Практика:**
1. Проверьте, доступен ли сайт: `curl -I https://google.com`.

---

## Заключение
Теперь вы знаете, как использовать основные утилиты для отладки и диагностики в Linux. Практикуйтесь в реальных сценариях, чтобы лучше понять поведение системы и научиться быстро находить и устранять проблемы.
